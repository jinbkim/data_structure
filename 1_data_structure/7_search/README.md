## 1. 보간탐색
- 데이터의 위치를 고려하여 탐색
- arr : 탐색 대상 배열 
- first : 탐색 대상의 시작
- last : 탐색 대상의 끝
- target : 찾는 데이터의 위치
- (arr[last] - arr[first]) : (arr[target] - arr[first]) = (last - first) : (target - first)
- target = (arr[target] - arr[first]) * (last - first) / (arr[last] - arr[first]) + first
## 2.이진 탐색트리
- 노드의 key는 유일
- 왼쪽 서브트리의 모든 노드들의 key보다 루트 노드의 key가 큼 
- 오른쪽 서브트리의 모든 노드들의 key보다 루트 노드의 key가 작음 
### (void) bst_init(t_bt_node **root_node)
- 루트노드 NULL로 초기화
### (void) bst_insert(t_bt_node **root_node, bt_data data)
- 루트노드가 비어있다면 새로운 노드는 루트노드 
- 새로운 노드가 들어갈 위치 찾기
- 찾은 위치의 부모노드와 연결
### (t_bt_node) *bst_remove(t_bt_node **root_node, bt_data data)
- 삭제할 노드가 루트노드 일때를 대비해, 가상루트노드 생성
#### 1) 삭제할 노드가 단말노드인 경우
- 삭제할 부모노드의 자식노드를 NULL 처리
#### 2) 삭제할 노드가 하나의 서브트리를 가질 경우
- 삭제할 노드의 부모노드와 삭제할 노드의 자식노드를 연결
#### 3) 삭제할 노드가 두개의 서브트리를 가질 경우
- 삭제할 노드의 오른쪽 서브트리에서 가장 작은 값을 지니는 대체노드 찾기
- 삭제할 노드에 대체노드의 값을 저장
- 대체노드가 왼쪽 자식노드이면 대체노드의 오른쪽 자식노드를  
  대체노드의 부모노드의 왼쪽에 연결
- 대체노드가 오른쪽 자식노드이면 대체노드의 오른쪽 자식노드를  
  대체노드의 부모노드의 오른쪽에 연결
- 삭제할노드가 대체노드를 가리키고 데이터 복구
## 3. AVL트리
- 균형인수 :  왼쪽 서브트리의 높이 - 오른쪽 서브트리의 높이 
- LL상태 : 자식노드 두개가 왼쪽으로 연이어 연결되있는 상태 
- RR상태 : 자식노드 두개가 오른쪽으로 연이어 연결되있는 상태
- LR상태 : 자식노드가 왼쪽으로 하나, 오른쪽으로 하나 연결되있는 상태 
- RL상태 : 자식노드가 오른쪽으로 하나, 왼쪽으로 하나 연결되있는 상태 
- 맨위노드를 A노드, 가운대 노드를 B노드, 맨아래노드를 C노드라 정의
### LL회전 (LL 상태)
- B노드는 A노드의 왼쪽 자식노드인 상태 
- B노드의 오른쪽 자식노드를 A노드의 왼쪽 자식노드로 연결
- A노드를 B노드의 오른쪽 자식노드로 연결
### RR회전 (RR 상태)
- B노드는 A노드의 오른쪽 자식노드인 상태 
- B노드의 왼쪽 자식노드를 A노드의 오른쪽 자식노드로 연결
- A노드를 B노드의 왼쪽 자식노드로 연결 
### LR회전 (LR 상태)
- B노드와 C노드를 부분적으로 RR회전
- LL상태가 되었고, 그상태에서 LL회전
### RL회전 (RL 상태)
- B노드와 C노드를 부분적으로 LL회전
- RR상태가 되었고, 그상태에서 RR회전
