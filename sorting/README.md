## 정렬 
### 1. 버블정렬 
#### 알고리즘 
- 우선순위가 낮은(값이 큰) 데이터를 맨뒤부터 저장 
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)
- 우선순위를 비교해나가면서 위치변경 반복  
  (***3*** ***2*** 4 1) -> (2 ***3*** ***4*** 1) -> (2 3 ***4*** ***1***) -> (***2*** ***3*** 1 4) ->  
  (2 ***3*** ***1*** 4) -> (2 1 ***3*** ***4***) -> (***2*** ***1*** 3 4) -> (1 2 3 4)
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : n^2
### 2. 선택정렬
#### 알고리즘
- 우선순위가 높은 (값이 작은) 데이터를 맨앞부터 저장
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)
- 우선순위가 가장 데이터의 위치를 찾고 위치변경 반복  
  (***3*** 2 4 ***1***) -> (1 ***2*** 4 3) -> (1 2 ***4*** ***3***) -> (1 2 3 4)
#### 성능
- 비교연산 빅오 : n^2 
- 데이터이동 빅오 : n
### 3. 삽입정렬
#### 알고리즘
- 우선순위가 낮은 데이터를 한칸씩 뒤로 밀면서 정렬
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)  
  (3 ***2*** 4 1) -> (2 3 ***4*** 1) -> (2 3 4 ***1***) -> (2 3 ***1*** 4) ->  
  (2 ***1*** 3 4) -> (1 2 3 4)
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : n^2
### 4. 힙 정렬
#### 알고리즘 
- 힙의 루트 노드에 저장된 값이 우선순위가 가장 높음 
- 힙에 넣었다가 꺼내면 정렬이 완료
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : nlog2(n)
### 5. 병합정렬
#### 알고리즘
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)
- 하나씩 구분이 될때까지 둘로 나누어 분할 (3   2   4   1)
- 우선순위에 따라 정렬과 결합을 반복  
  (***3*** ***2***   4 1) -> (2 3   ***4*** ***1***) -> (***2*** ***3***   ***1*** ***4***) ->  (1 2 3 4)
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : nlog2(n)
 
 
