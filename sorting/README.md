## 정렬 
### 1. 버블정렬 
#### 알고리즘 
- 우선순위가 낮은(값이 큰) 데이터를 맨뒤부터 저장 
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)
- 우선순위를 비교해나가면서 위치변경 반복  
  (***3*** ***2*** 4 1) -> (2 ***3*** ***4*** 1) -> (2 3 ***4*** ***1***) -> (***2*** ***3*** 1 4) ->  
  (2 ***3*** ***1*** 4) -> (2 1 ***3*** ***4***) -> (***2*** ***1*** 3 4) -> (1 2 3 4)
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : n^2
### 2. 선택정렬
#### 알고리즘
- 우선순위가 높은 (값이 작은) 데이터를 맨앞부터 저장
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)
- 우선순위가 가장 데이터의 위치를 찾고 위치변경 반복  
  (***3*** 2 4 ***1***) -> (1 ***2*** 4 3) -> (1 2 ***4*** ***3***) -> (1 2 3 4)
#### 성능
- 비교연산 빅오 : n^2 
- 데이터이동 빅오 : n
### 3. 삽입정렬
#### 알고리즘
- 우선순위가 낮은 데이터를 한칸씩 뒤로 밀면서 정렬
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)  
  (3 ***2*** 4 1) -> (2 3 ***4*** 1) -> (2 3 4 ***1***) -> (2 3 ***1*** 4) ->  
  (2 ***1*** 3 4) -> (1 2 3 4)
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : n^2
### 4. 힙정렬
#### 알고리즘 
- 힙의 루트 노드에 저장된 값이 우선순위가 가장 높음 
- 힙에 넣었다가 꺼내면 정렬이 완료
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : nlog2(n)
### 5. 병합정렬
#### 알고리즘
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)
- 하나씩 구분이 될때까지 둘로 나누어 분할 (3   2   4   1)
- 우선순위에 따라 정렬과 결합을 반복  
  (***3*** ***2*** 4 1) -> (2 3 ***4*** ***1***) -> (***2*** ***3*** ***1*** ***4***) ->  (1 2 3 4)
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : nlog2(n)
### 6. 퀵정렬
#### 알고리즘
- 4개의 데이터가 배열에 있다고 가정 (3 2 4 1)
1. 가장 왼쪽의 데이터를 pivot(기준점)으로 정함  
  (***3(pivot)*** 2 4 1)
2. 피벗을 제외한 가장왼쪽의 데이터를 low로 정함  
  (3 ***2(low)*** 4 1)
3. 가장 오른쪽 데이터를 high로 정함  
  (3 2 4 ***1(high)***)
4. 피벗보다 우선순위가 낮은 데이터를 만날때까지,  
  low <= high를 유지하며, low는 오른쪽으로 이동  
  (3 2 ***4(low)*** 1)
5. 피벗보다 우선순위가 높은 데이터를 만날때까지,  
  pivot < high를 유지하며, high는 왼쪽으로 이동  
  (3 2 4 ***1(high)***)
6. low <= high 이면, low와 high 위치의 데이터 교환  
  (3 2 ***4(low)*** ***1(high)***) - > (3 2 ***1*** ***4***)
7. 그이후에도 low <= high 이면 4 ~ 6 과정을 반복  
  (3 2 ***1(low)*** ***4(high)***) -> (3 2 ***1(high)*** ***4(low)***) 
8. pivot과 high위치에 있는 데이터 교환  
  (***3(pivot)*** 2 ***1(high)*** 4) -> (***1(pivot)*** 2 ***3(high)*** 4)
9. high 위치를 pivot으로 정함  
  (1 2 ***3(pivot)*** 4)
10. pivot을 제외한 범위에서 다시 1 ~ 9 과정을 반복하며 정렬
#### 성능
- 비교연산 빅오 = 데이터이동 빅오 : nlog2(n)
